#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
This script reads the pickle output files generated by the crawlers, normalize
the artists' names and song lyrics, splits the dataset into training and test
sets and saves them for further processing by another module.
"""

import os
import re
import pickle
import string
import numpy as np

OUTPUT_TRAIN_DATASET_FILE = os.path.join('out', 'train_set_pickle')
OUTPUT_TEST_DATASET_FILE = os.path.join('out', 'test_set_pickle')
INPUT_PICKLE_FILE = os.path.join('out', 'lyrics_pickle_processed_dict')


def read_pickle_file(pickle_path):
    """
    Given a path to the pre-processed pickle file, this function reads the data
    contained in it and returns the {website|artist|song-name, song-lyrics}
    dictionary stored within.

    Arguments:
    pickle_path -- The path to the pickle file.

    Returns:
    A dictionary with the data stored inside the path given as parameter.
    """
    if not pickle_path or len(pickle_path) == 0:
        raise ValueError('Invalid path list given')

    print('Trying to read file: {}'.format(pickle_path))
    if not os.path.exists(pickle_path):
        print('WARNING: File {} was not found. Continuing.'.format(pickle_path))
        return {}

    lyrics_tuple_list = {}
    with open(pickle_path, 'rb') as file_in:
        lyrics_tuple_list = pickle.load(file_in)

    return lyrics_tuple_list


def build_train_validation_test_sets(song_list, train_proportion):
    """
    Given a list of songs and a proportion of training elements, this functions
    selects uniformly at random which songs will compose the training and test
    datasets.

    Arguments:
    song_list -- A list of songs. Each song is a tuple of
    (website, artist-name, song-name and song-lyrics).
    train_proporion -- The percentage of elements to assign to the training set.
    This value must be in range (0, 1)

    Returns:
    Two lists, the first contains the training set, and the second contains the
    test set.
    """
    if not song_list or len(song_list) == 0:
        raise ValueError('Invalid list of songs.')
    if train_proportion >= 1 or train_proportion <= 0:
        raise ValueError('Invalid train set proportion. Value must be in range (0, 1)')
    
    choice = np.random.sample(len(song_list))
    train_set = dict([(k, s) for i, (k, s) in enumerate(song_list.items()) if choice[i] <= train_proportion])
    test_set = dict([(k, s) for i, (k, s) in enumerate(song_list.items()) if choice[i] > train_proportion])
    return train_set, test_set

if __name__ == '__main__':
    lyrics_list = read_pickle_files(PICKLE_FILE_LIST)
    #lyrics_list = normalize_dataset(lyrics_list)
    train_set, test_set = build_train_test_sets(lyrics_list, 0.7)

    choice = np.random.sample(len(train_set))
    new_train_set = dict([(k, s) for i, (k, s) in enumerate(train_set.items()) if choice[i] <= 0.86])
    validation_set = dict([(k, s) for i, (k, s) in enumerate(train_set.items()) if choice[i] > 0.86])
    
    pickle.dump(new_train_set, open(OUTPUT_TRAIN_DATASET_FILE, 'wb'))
    pickle.dump(validation_set, open(os.path.join('out', 'validation_set_pickle'), 'wb'))
    pickle.dump(test_set, open(OUTPUT_TEST_DATASET_FILE, 'wb'))
