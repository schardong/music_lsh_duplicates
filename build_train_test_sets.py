#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
This script reads the pickle output files generated by the crawlers, normalize
the artists' names and song lyrics, splits the dataset into training and test
sets and saves them for further processing by another module.
"""

import os
import re
import pickle
import string
import numpy as np

OUTPUT_TRAIN_DATASET_FILE = os.path.join('out', 'train_set_pickle')
OUTPUT_TEST_DATASET_FILE = os.path.join('out', 'test_set_pickle')
PICKLE_FILE_LIST = [os.path.join('out', 'lyrics_pickle_output_vagalume_0'),
                    os.path.join('out', 'lyrics_pickle_output_letras'),
                    os.path.join('out', 'lyrics_pickle_output_musica'),
                    os.path.join('out', 'lyrics_pickle_output_letras_de_musicas')]


def read_pickle_files(path_list):
    """
    Given a list of paths to the pickle files, this function reads each one of
    them and returns a list of tuples, where each tuple is of the form
    (website, artist-name, song-name, song-lyrics), where all fields are strings.

    Arguments:
    path_list -- A list containing the paths to the pickle files.

    Returns:
    A list of tuples with the data inside the pickle files.
    """
    if not path_list or len(path_list) == 0:
        raise ValueError('Invalid path list given')

    lyrics_list = []
    for path in path_list:
        print('Trying to read file: {}'.format(path))
        if not os.path.exists(path):
            print('WARNING: File {} was not found. Continuing.'.format(path))
            continue
        with open(path, 'rb') as file_in:
            lyrics_tuple_list = pickle.load(file_in)
            lyrics_list.extend(lyrics_tuple_list)

    return lyrics_list


def normalize_string(input_text):
    """
    Given an input string, this function removes all special characters and
    returns a clean version of the original text. Any quote characters are
    replaced by an empty string.

    Arguments:
    input_text -- The input string

    Returns:
    A cleaned-up version of the input text.
    """
    if input_text is None or len(input_text) == 0:
        raise ValueError('Invalid list of song lyrics.')

    tmp_text = input_text.replace('\'', '').lower()
    normalized_text = re.sub('[' + string.punctuation + string.whitespace + ']',
                             ' ',
                             tmp_text)
    normalized_text = ' '.join(normalized_text.split())
    return normalized_text


def normalize_dataset(song_list):
    """
    Given a list of song tuples, this function normalizes the artist name, song
    name and song lyrics in order to remove special characters. The song tuples
    must be in the form: (website, artist-name, song-name, song-lyrics).

    Arguments:
    song_list -- A list of songs.

    Retuns:
    A list of tuples in the same format as the input song_list, however, the
    songs' name and lyrics, as well as the artists' names are normalized. Any
    missing fields in a tuple will not be included in the final list.
    """
    if not song_list or len(song_list) == 0:
        raise ValueError('Invalid list of songs.')

    normalized_song_list = []
    for song in song_list:
        if all([len(s) for s in song]) is False:
            continue
        artist = normalize_string(song[1])
        song_name = normalize_string(song[2])
        lyrics = normalize_string(song[3])
        normalized_song_list.append((song[0], artist, song_name, lyrics))

    return normalized_song_list


def build_train_test_sets(song_list, train_proportion):
    """
    Given a list of songs and a proportion of training elements, this functions
    selects uniformly at random which songs will compose the training and test
    datasets.

    Arguments:
    song_list -- A list of songs. Each song is a tuple of
    (website, artist-name, song-name and song-lyrics).
    train_proporion -- The percentage of elements to assign to the training set.
    This value must be in range (0, 1)

    Returns:
    Two lists, the first contains the training set, and the second contains the
    test set.
    """
    if not song_list or len(song_list) == 0:
        raise ValueError('Invalid list of songs.')
    if train_proportion >= 1 or train_proportion <= 0:
        raise ValueError('Invalid train set proportion. Value must be in range (0, 1)')
    
    choice = np.random.sample(len(song_list))
    train_set = [s for i, s in enumerate(song_list) if choice[i] <= train_proportion]
    test_set = [s for i, s in enumerate(song_list) if choice[i] > train_proportion]
    return train_set, test_set

if __name__ == '__main__':
    lyrics_list = read_pickle_files(PICKLE_FILE_LIST)
    lyrics_list = normalize_dataset(lyrics_list)
    train_set, test_set = build_train_test_sets(lyrics_list, 0.7)
    
    pickle.dump(train_set, open(OUTPUT_TRAIN_DATASET_FILE, 'wb'))
    pickle.dump(test_set, open(OUTPUT_TEST_DATASET_FILE, 'wb'))
